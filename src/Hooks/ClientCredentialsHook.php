<?php

/**
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

namespace formance\stack\Hooks;

use Brick\DateTime\LocalTime;
use Brick\DateTime\TimeZone;
use formance\stack\Utils;
use GuzzleHttp\ClientInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Speakeasy\Serializer\DeserializationContext;

class ClientCredentialsHook implements AfterErrorHook, BeforeRequestHook, SDKInitHook
{
    public string $baseUrl;
    /**
     * @var array<string, Session> $sessions
     */
    public array $sessions;
    public ClientInterface $client;

    public function sdkInit(string $baseUrl, ClientInterface $client): SDKRequestContext
    {
        $this->baseUrl = $baseUrl;
        $this->sessions = [];
        $this->client = $client;

        return new SDKRequestContext($baseUrl, $client);
    }

    public function beforeRequest(BeforeRequestContext $context, RequestInterface $request): RequestInterface
    {
        if ($context->oauth2Scopes == null) {
            // OAuth2 not in use
            return $request;
        }

        $credentials = $this->getCredentials($context->securitySource);
        if ($credentials == null) {
            return $request;
        }

        $sessionKey = $this->getSessionKey($credentials->clientID, $credentials->clientSecret);

        if (! array_key_exists($sessionKey, $this->sessions) || ! $this->hasRequiredScopes($this->sessions[$sessionKey]->scopes, $context->oauth2Scopes) || $this->hasTokenExpired($this->sessions[$sessionKey]->expiresAt)) {
            $value = isset($this->sessions[$sessionKey]) ? $this->sessions[$sessionKey] : null;
            $session = $this->doTokenRequest(
                $credentials,
                $this->getScopes($context->oauth2Scopes, $value)
            );

            $this->sessions[$sessionKey] = $session;
        }

        $request = $request->withoutHeader('Authorization');
        $request = $request->withHeader('Authorization', 'Bearer '.$this->sessions[$sessionKey]->token);

        return $request;
    }

    public function afterError(AfterErrorContext $context, ?ResponseInterface $response, ?\Throwable $exception): ErrorResponseContext
    {
        if ($context->oauth2Scopes === null) {
            // OAuth2 not in use
            return new ErrorResponseContext($response, $exception);
        }

        if ($exception !== null) {
            // We don't want to refresh the token if the error is not related to the token
            return new ErrorResponseContext($response, $exception);
        }

        $credentials = $this->getCredentials($context->securitySource);
        if ($credentials === null) {
            return new ErrorResponseContext($response, $exception);
        }

        if ($response !== null && $response->getStatusCode() === 401) {
            $sessionKey = $this->getSessionKey($credentials->clientID, $credentials->clientSecret);

            if (array_key_exists($sessionKey, $this->sessions)) {
                unset($this->sessions[$sessionKey]);
            }
        }

        return new ErrorResponseContext($response, $exception);
    }

    private function getCredentials(?\Closure $securitySource): ?Credentials
    {
        if ($securitySource == null) {
            return null;
        }

        $security = $securitySource();

        if ($security->clientID == null || $security->clientSecret == null) {
            return null;
        }

        return new Credentials(
            $security->clientID,
            $security->clientSecret,
            $security->tokenURL
        );
    }

    /**
     * @param  Credentials  $credentials
     * @param  array<string>  $scopes
     *
     * @return Session
     */
    private function doTokenRequest(Credentials $credentials, array $scopes): Session
    {
        $payload = ['grant_type' => 'client_credentials',
            'client_id' => $credentials->clientID,
            'client_secret' => $credentials->clientSecret,
        ];

        if (count($scopes) > 0) {
            $payload['scope'] = implode(' ', $scopes);
        }
        $options = ['form_params' => $payload];
        $request = new \GuzzleHttp\Psr7\Request('POST', Utils\Utils::urljoin($this->baseUrl, $credentials->tokenURL));

        $response = $this->client->send($request, $options);
        $responseBody = $response->getBody();

        if ($response->getStatusCode() !== 200) {
            throw new \Exception("Unexpected status code {$response->getStatusCode()}: {$responseBody}");
        }
        $serializer = Utils\JSON::createSerializer();

        try {
            $tokenResponse = $serializer->deserialize($responseBody, 'formance\stack\Hooks\TokenResponse', 'json', DeserializationContext::create()->setRequireAllRequiredProperties(true));
        } catch (\Exception $ex) {
            throw new \Exception("Failed to decode token response: {$ex->getMessage()}", $ex->getCode(), $ex);
        }

        if ($tokenResponse->tokenType !== 'Bearer') {
            throw new \Exception("Unexpected token type {$tokenResponse->tokenType}");
        }

        $expiresAt = null;
        if ($tokenResponse->expiresIn != null) {
            $expiresAt = LocalTime::now(TimeZone::utc())->plusSeconds($tokenResponse->expiresIn->value);
        }

        return new Session($credentials, $tokenResponse->accessToken, $scopes, $expiresAt);
    }

    private function getSessionKey(string $clientID, string $clientSecret): string
    {
        return md5("{$clientID}:{$clientSecret}");
    }

    /**
     * @param  array<string>  $sessionScopes
     * @param  array<string>  $requiredScopes
     *
     * @return bool
     */
    private function hasRequiredScopes(array $sessionScopes, array $requiredScopes): bool
    {
        foreach ($requiredScopes as $requiredScope) {
            if (! array_search($requiredScope, $sessionScopes)) {
                return false;
            }
        }

        return true;
    }

    /**
     * @param  array<string>  $requiredScopes
     * @param  Session|null  $session
     *
     * @return array<string>
     */
    private function getScopes(array $requiredScopes, ?Session $session): array
    {
        if ($session != null) {
            $scopes = array_unique(array_merge($requiredScopes, $session->scopes));

            return $scopes;
        }

        return $requiredScopes;
    }

    private function hasTokenExpired(?LocalTime $expiresAt): bool
    {
        return $expiresAt === null || LocalTime::now(TimeZone::utc())->plusSeconds(60) >= $expiresAt;
    }
}
